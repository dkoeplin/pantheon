Out function(In a, In b, Out c) = {

}


/*
val function = {(a: Matrix, b: Matrix, c: Matrix): Matrix =>

}


(Matrix, Matrix, Matrix, Tensor[Matrix[Int]]) function(
  Matrix          a,
  Tensor[Int]     b,
  Caption[Double] c
): {

}


add[A](a: A, b: A): A = (a,b) ? {
  [Add(x,y)] x + y
  [Sub(x,y)] x - y
}



Array(Int)$ my_function = {(Matrix a, Matrix b, Matrix c, Int e, Int j, Int f, Int i, Double d, Float f, Int g, Matrix h):
  x: Int* = 32
  y = x + 64

  var z: Int = if (x) 32 else if (y) 16

  Int z = {[x] 32 [y] 16}

  x => {
   |32| x = Int(x) + 1
   |64| x = x + 2
  }



    m <: Int =>
  | m <: Int => 32


  |m <: Int & a & b & c & d & e & f & g & h & j & k & l & m & n|
    x = z + 32
  |m <: Double|
    x = z + 62
  x




  x = y.map{|x @ Int: 32 |x @ Double: 64}.map{x: 32}
}

/** $Type  -- function which has a result of Type
  * #Type  -- macro value of Type (defined at compile time)
  * Type*  -- variable of Type (mutable pointer)
  * Type?  -- option of Type
  * Type!  --
  * Type+  --
  * @Type  --
  *
  * #$Type -- function which returns a macro Type
  * $Type* -- variable function
  * #Type* -- macro variable
  *
  **/

/*
Def[Array] my_function = (...) =>


Def<Array> my_function =

$Array$ my_function = {

}*/